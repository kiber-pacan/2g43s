#version 460#extension GL_EXT_buffer_reference2 : require#extension GL_EXT_scalar_block_layout : enablelayout(binding = 0) uniform sampler2D texSampler;layout(binding = 1) uniform sampler2D depthSampler;layout(location = 0) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;layout(scalar, buffer_reference) buffer UPB {    vec2 resolution;    float time;};layout(push_constant) uniform Push {    UPB upb;} pc;const float NEAR = 0.1;const float FAR = 4096.0;float linearizeDepth(float d) {    return (NEAR * FAR) / (FAR + d * (NEAR - FAR));}const float exposure = 1.5;const float bloomThreshold = 0.7;const float bloomScale = 0.8;const float gamma = 2.2;const float fogDensity = 0.013;const vec3 fogColor = vec3(200, 200, 200) / 255;const float chromaticStrength = 2;vec3 ACESFilm(vec3 x) {    x *= 0.85;    float a = 2.51;    float b = 0.03;    float c = 2.43;    float d = 0.59;    float e = 0.14;    vec3 result = clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);    result = pow(result, vec3(1.1));    return result;}vec3 applyCAS(sampler2D tex, vec2 uv, float sharpness) {    // Sharpness: 0.0 - нет, 1.0 - максимум    vec3 w = texture(tex, uv).rgb;    // Выборка соседей (крестом)    vec3 a = textureOffset(tex, uv, ivec2(0, -1)).rgb;    vec3 b = textureOffset(tex, uv, ivec2(-1, 0)).rgb;    vec3 d = textureOffset(tex, uv, ivec2(1, 0)).rgb;    vec3 e = textureOffset(tex, uv, ivec2(0, 1)).rgb;    float min_g = min(min(min(a.g, b.g), d.g), e.g);    float max_g = max(max(max(a.g, b.g), d.g), e.g);    // Вычисляем вес резкости    float weight = sqrt(clamp((1.0 - max_g) / max_g, 0.0, 1.0)) * sharpness;    return clamp(w + (w - (a + b + d + e) * 0.25) * weight, 0.0, 1.0);}void main() {    vec2 uv = fragTexCoord;    // Distance from center of screen    vec2 center = fragTexCoord * 2.0 - 1.0;    float len = length(center);    // Depth    float rawDepth = texture(depthSampler, uv).r;    float dist = linearizeDepth(rawDepth);    bool sky = dist >= 0.999;    float amount = (1.0 - exp(-pow(len, 2.6) / 256.0)) * chromaticStrength;    vec2 dir = uv - 0.5;    float r = texture(texSampler, uv - dir * amount * 0.5).r;    float g = texture(texSampler, uv - dir * amount * 1.0, 0.84).g;    float b = texture(texSampler, uv - dir * amount * 1.5).b;    vec3 hdrColor = vec3(r, g, b);    // 2. ИМИТАЦИЯ БЛЮМА (Pseudo-Bloom)    // В идеале делается в несколько пассов, но мы сделаем быстрый 5-tap для "мягкости"    float offset = 0.003;    vec3 blur = texture(texSampler, uv).rgb * 0.204;    blur += texture(texSampler, uv + vec2(offset, 0)).rgb * 0.199;    blur += texture(texSampler, uv - vec2(offset, 0)).rgb * 0.199;    blur += texture(texSampler, uv + vec2(0, offset)).rgb * 0.199;    blur += texture(texSampler, uv - vec2(0, offset)).rgb * 0.199;    // Выделяем только яркие участки для свечения    vec3 bloom = max(blur - vec3(bloomThreshold), 0.0);    // 3. ПРИМЕНЯЕМ ЭКСПОЗИЦИЮ (как в HL2 при адаптации зрения)    // Можно добавить пульсацию, если персонаж только что вышел из тени    hdrColor *= exposure;    bloom *= bloomScale;    // 4. СМЕШИВАНИЕ (Add-blend)    vec3 result = hdrColor + bloom;    // 5. ТОНМАППИНГ (Reinhard)    // Это превращает HDR-величины (которые > 1.0) в понятные монитору LDR (0..1)    // Именно это дает "киношный" мягкий вид вместо вырвиглазных пикселей    vec3 mapped = result / (result + vec3(1.0));    // 6. ГАММА-КОРРЕКЦИЯ    mapped = ACESFilm(pow(mapped, vec3(1.0 / gamma)));    float noise = fract(sin(dot(uv, vec2(12.9898, 78.233 + pow(sin(pc.upb.time), 3)))) * 43758.5453);    float dynamicDensity = fogDensity + (noise * fogDensity);    float fogFactor = 1.0 - exp(-pow(dist * dynamicDensity, 0.96) * 1.8);    vec3 finColor = mix(mapped, fogColor, fogFactor);    // Vignette    vec3 vignette = vec3(exp(-pow(len, 2.4) / 4));    vec3 vignetteColor = mix(finColor, vec3(0), 1 - vignette);    outColor = vec4(vignetteColor, 1.0);}