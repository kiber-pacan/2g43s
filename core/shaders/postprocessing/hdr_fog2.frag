#version 460#extension GL_EXT_buffer_reference2 : require#extension GL_EXT_scalar_block_layout : enablelayout(binding = 0) uniform sampler2D texSampler;layout(binding = 1) uniform sampler2D depthSampler;layout(location = 0) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;layout(scalar, buffer_reference) buffer UPB {    vec2 resolution;    float time;};layout(push_constant) uniform Push {    UPB upb;} pc;const float NEAR = 0.1;const float FAR = 4096.0;float linearizeDepth(float d) {    return (NEAR * FAR) / (FAR + d * (NEAR - FAR));}// Параметры для твоего вайбаconst float exposure = 1.3;const float bloomThreshold = 0.8;const float bloomScale = 0.4;const float gamma = 2.0;const float fogDensity = 0.012;const vec3 fogColor = vec3(180, 190, 200) / 255.0;const float chromaticStrength = 0.8;vec3 ACESFilm(vec3 x) {    x *= 0.85;    float a = 2.51;    float b = 0.03;    float c = 2.43;    float d = 0.59;    float e = 0.14;    vec3 result = clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);    // Для лиминальности: слегка осветляем тени (снижаем контраст)    return pow(result, vec3(0.95));}// Улучшенный CAS, работающий с динамическими UVvec3 applyCAS(sampler2D tex, vec2 uv, float sharpness) {    vec3 w = texture(tex, uv).rgb;    // Используем малые смещения в зависимости от разрешения    vec2 off = 1.0 / pc.upb.resolution;    vec3 a = texture(tex, uv + vec2(0, -off.y)).rgb;    vec3 b = texture(tex, uv + vec2(-off.x, 0)).rgb;    vec3 d = texture(tex, uv + vec2(off.x, 0)).rgb;    vec3 e = texture(tex, uv + vec2(0, off.y)).rgb;    float min_g = min(min(min(a.g, b.g), d.g), e.g);    float max_g = max(max(max(a.g, b.g), d.g), e.g);    float weight = sqrt(clamp((1.0 - max_g) / (max_g + 0.001), 0.0, 1.0)) * sharpness;    return clamp(w + (w - (a + b + d + e) * 0.25) * weight, 0.0, 1.0);}void main() {    vec2 uv = fragTexCoord;    vec2 center = uv * 2.0 - 1.0;    float len = length(center);    float rawDepth = texture(depthSampler, uv).r;    float dist = linearizeDepth(rawDepth);    // 1. ХРОМАТИЧЕСКАЯ АБЕРРАЦИЯ + CAS (Резкость на входе)    float amount = (1.0 - exp(-pow(len, 2.6) / 256.0)) * chromaticStrength * 0.05;    vec2 dir = uv - 0.5;    // Применяем CAS к каждому цветовому каналу отдельно    // Это даст "звенящую" четкость каждой травинке    float r = applyCAS(texSampler, uv - dir * amount * 0.5, 0.8).r;    float g = applyCAS(texSampler, uv - dir * amount * 1.0, 0.8).g;    float b = applyCAS(texSampler, uv - dir * amount * 1.5, 0.8).b;    vec3 hdrColor = vec3(r, g, b);    // 2. PSEUDO-BLOOM (Мягкое свечение неба)    float bOffset = 0.002;    vec3 blur = texture(texSampler, uv + vec2(bOffset, bOffset)).rgb;    blur += texture(texSampler, uv - vec2(bOffset, bOffset)).rgb;    vec3 bloom = max(blur * 0.5 - vec3(bloomThreshold), 0.0) * bloomScale;    // 3. ОБРАБОТКА ЦВЕТА    hdrColor *= exposure;    vec3 result = hdrColor + bloom;    // Тонмаппинг    vec3 mapped = result / (result + vec3(1.0));    mapped = ACESFilm(pow(mapped, vec3(1.0 / gamma)));    // 4. ТУМАН (Стиль: Линейно-экспоненциальный "Old Game")    float noise = fract(sin(dot(uv, vec2(12.9898, 78.233 + pc.upb.time))) * 43758.5453);    float dynamicDensity = fogDensity + (noise * 0.002);    // fogFactor: 0.0 - близко, 1.0 - стена тумана    float fogFactor = 1.0 - exp(-pow(dist * dynamicDensity, 1.2));    fogFactor = clamp(fogFactor, 0.0, 1.0);    vec3 finColor = mix(mapped, fogColor, fogFactor);    // 5. ВИНЬЕТКА (мягкая, для концентрации внимания)    float vignette = exp(-pow(len, 2.0) / 3.0);    vec3 vignetteColor = mix(finColor, vec3(0.02), 1.0 - vignette); // Не в полный черный    // 6. АНИМИРОВАННЫЙ ШУМ (В самом конце!)    // Очень слабый, "цифровой"    vignetteColor += (noise - 0.5) * 0.015;    outColor = vec4(vignetteColor, 1.0);}