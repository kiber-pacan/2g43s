#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_vote : enable

layout (local_size_x = 128) in;

struct MCBO {
    vec4 sphere;
    uint index;
};

struct VIBO {
    uint index;
};

struct DCO {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout(std430, binding = 0) readonly buffer MCB {
    MCBO objects[];
} mcb;

layout(std430, binding = 1) writeonly buffer VIB {
    VIBO objects[];
} vib;

layout(std430, binding = 2) buffer DCB {
    DCO objects[];
} dcb;

struct Frustum {
    vec4 planes[6];
};

layout(binding = 3) uniform UCBO {
    vec4 frustumPlanes[6];
    uint totalObjects;
} ucbo;

layout(std430, binding = 4) buffer COUNTER {
    uint count;
} counter;

bool isSphereInFrustum(vec4 sphere, vec4 f[6]) {
    vec3 center = sphere.xyz;
    float radius = sphere.w;

    for (int i = 0; i < 6; ++i) {
        float dist = dot(f[i].xyz, center) + f[i].w;
        if (dist < -radius) {
            return false;
        }
    }
    return true;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= ucbo.totalObjects) return;

    // 1. Проверка видимости
    bool visible = isSphereInFrustum(mcb.objects[index].sphere, ucbo.frustumPlanes);

    // 2. Получаем маску всех видимых потоков в подгруппе
    uvec4 ballot = subgroupBallot(visible);

    // Если в подгруппе вообще никто ничего не видит — выходим сразу
    if (!subgroupAny(visible)) return;

    uint drawCommandIndex = mcb.objects[index].index;

    // --- ОПТИМИЗАЦИЯ: СКАЛЯРИЗАЦИЯ ---
    // Перебираем все уникальные DrawCommandIndex внутри подгруппы
    uvec4 processedBallot = uvec4(0);

    // Пока не обработаем все видимые потоки в подгруппе
    while (subgroupAny((ballot.x ^ processedBallot.x) != 0 || (ballot.y ^ processedBallot.y) != 0 ||
    (ballot.z ^ processedBallot.z) != 0 || (ballot.w ^ processedBallot.w) != 0)) {

        // Находим первый необработанный поток
        uint firstUnprocessed = subgroupBallotFindLSB(ballot ^ processedBallot);

        // Получаем ID модели, которую этот поток хочет отрисовать
        uint candidateID = subgroupBroadcast(drawCommandIndex, firstUnprocessed);

        // Находим все потоки в подгруппе, которые хотят рисовать ЭТУ ЖЕ модель
        uvec4 sameModelBallot = subgroupBallot(visible && (drawCommandIndex == candidateID));
        uint countForThisModel = subgroupBallotBitCount(sameModelBallot);

        uint baseIdx = 0;

        // Только один поток (лидер этой группы в подгруппе) делает атомарную операцию
        if (gl_SubgroupInvocationID == firstUnprocessed) {
            baseIdx = atomicAdd(dcb.objects[candidateID].instanceCount, countForThisModel);

            // Если это первые инстансы этой модели — увеличиваем счетчик команд
            if (baseIdx == 0) {
                atomicAdd(counter.count, 1);
            }
        }

        // Рассылаем полученный baseIdx всем потокам с этой же моделью
        baseIdx = subgroupBroadcast(baseIdx, firstUnprocessed);

        // Если текущий поток относится к этой модели — пишем результат
        if (visible && (drawCommandIndex == candidateID)) {
            uint localOffset = subgroupBallotExclusiveBitCount(sameModelBallot);
            uint firstInstance = dcb.objects[candidateID].firstInstance;

            vib.objects[baseIdx + localOffset + firstInstance].index = index;
        }

        // Помечаем эти потоки как обработанные
        processedBallot |= sameModelBallot;
    }
}