#version 460
layout (local_size_x = 128) in;

struct MCBO {
    vec4 sphere;
};

struct VIBO {
    uint index;
};

layout(std430, binding = 0) readonly buffer MCB {
    MCBO objects[];
} mcb;

layout(std430, binding = 1) writeonly buffer VIB {
    VIBO objects[];
} vib;

layout(std430, binding = 2) writeonly buffer ACB {
    uint count;
} acb;

struct Frustum {
    vec4 planes[6];
};

layout(binding = 3) uniform UCBO {
    vec4 frustumPlanes[6];
    uint totalObjects;
} ucbo;


bool isSphereInFrustum(vec4 sphere, vec4 f[6]) {
    vec3 center = sphere.xyz;
    float radius = sphere.w;

    // Check sphere against all 6 frustum planes
    for (int i = 0; i < 6; ++i) {
        // Distance from plane: Ax + By + Cz + D
        // Since planes are normalized (length(normal)=1), this is the signed distance.
        // If normal points OUTWARDS, negative distance means outside.
        float dist = dot(f[i].xyz, center) + f[i].w;

        // If the sphere is completely outside *any* plane, it's outside the frustum.
        // If normal points OUTWARDS, dist < -radius means it's outside.
        if (dist < -radius) {
            return false;
        }
    }
    // If the sphere is not completely outside any plane, it's considered inside or intersecting.
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= ucbo.totalObjects) return;

    if (isSphereInFrustum(mcb.objects[idx].sphere, ucbo.frustumPlanes)) {
        // Atomic operation (slow, but necessary for counting/indexing)
        uint outIdx = atomicAdd(acb.count, 1);

        if (outIdx < ucbo.totalObjects) {
            vib.objects[outIdx].index = idx;
        }
    }
}
