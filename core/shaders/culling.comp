#version 460

#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : enable

layout (local_size_x = 128) in;

struct MCBO {
    vec4 sphere;
    uint index;
    uint pad[3];
};

struct VIBO {
    uint index;
};

struct DCO {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

struct UCBO {
    vec4 frustumPlanes[6];
    uint totalObjects;
};

layout(scalar, buffer_reference) readonly buffer MCB {
    MCBO objects[];
};

layout(scalar, buffer_reference, buffer_reference_align = 4) writeonly buffer VIB {
    VIBO objects[];
};

layout(scalar, buffer_reference) buffer DCSB {
    DCO objects[];
};

layout(scalar, buffer_reference) buffer DCB {
    DCO objects[];
};

layout(scalar, buffer_reference) readonly buffer UCB {
    UCBO data;
};

layout(scalar, buffer_reference) buffer Counter {
    uint count;
};

layout(push_constant) uniform Push {
    MCB mcb;
    VIB vib;
    DCSB dcsb;
    DCB dcb;
    UCB ucbo;
    Counter counter;
} pc;

bool isSphereInFrustum(vec4 sphere, vec4 f[6]) {
    vec3 center = sphere.xyz;
    float radius = sphere.w;
    for (int i = 0; i < 6; ++i) {
        float dist = dot(f[i].xyz, center) + f[i].w;
        if (dist < -radius) return false;
    }

    return true;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= pc.ucbo.data.totalObjects) return;

    // 1. Checking if current instance is actually visible
    bool visible = isSphereInFrustum(pc.mcb.objects[index].sphere, pc.ucbo.data.frustumPlanes);

    // 2. Получаем маску всех видимых потоков в подгруппе
    uvec4 ballot = subgroupBallot(visible);

    // Если в подгруппе вообще никто ничего не видит — выходим сразу
    if (!subgroupAny(visible)) return;

    uint modelIndex = pc.mcb.objects[index].index;

    // Work until all the subgroups stop working
    uvec4 processedBallot = uvec4(0);
    while (any(notEqual(ballot, processedBallot))) {

        // Находим первый необработанный поток
        uint firstUnprocessed = subgroupBallotFindLSB(ballot ^ processedBallot);

        // Получаем ID модели, которую этот поток хочет отрисовать
        uint candidateID = subgroupBroadcast(modelIndex, firstUnprocessed);

        // Находим все потоки в подгруппе, которые хотят рисовать ЭТУ ЖЕ модель
        uvec4 sameModelBallot = subgroupBallot(visible && (modelIndex == candidateID));
        uint countForThisModel = subgroupBallotBitCount(sameModelBallot);

        uint baseIdx = 0;

        // Только один поток (лидер этой группы в подгруппе) делает атомарную операцию
        if (gl_SubgroupInvocationID == firstUnprocessed) {
            baseIdx = atomicAdd(pc.dcsb.objects[candidateID].instanceCount, countForThisModel);

            // Если это первые инстансы этой модели — увеличиваем счетчик команд
            if (baseIdx == 0) {
                uint count = atomicAdd(pc.counter.count, 1);
                pc.dcb.objects[count].indexCount = pc.dcsb.objects[candidateID].indexCount;
                pc.dcb.objects[count].instanceCount = pc.dcsb.objects[candidateID].instanceCount;
                pc.dcb.objects[count].firstIndex = pc.dcsb.objects[candidateID].firstIndex;
                pc.dcb.objects[count].vertexOffset = pc.dcsb.objects[candidateID].vertexOffset;
                pc.dcb.objects[count].firstInstance = pc.dcsb.objects[candidateID].firstInstance;
            }
        }

        // Рассылаем полученный baseIdx всем потокам с этой же моделью
        baseIdx = subgroupBroadcast(baseIdx, firstUnprocessed);

        // Если текущий поток относится к этой модели — пишем результат
        if (visible && (modelIndex == candidateID)) {
            uint localOffset = subgroupBallotExclusiveBitCount(sameModelBallot);
            uint firstInstance = pc.dcsb.objects[candidateID].firstInstance;

            pc.vib.objects[baseIdx + localOffset + firstInstance].index = index;
        }

        // Помечаем эти потоки как обработанные
        processedBallot |= sameModelBallot;
    }
}