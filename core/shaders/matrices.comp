#version 460
layout (local_size_x = 256) in;

struct MBO {
    mat4 model;
};

struct MDBO {
    vec4 pos;
    vec4 rot;
    vec4 scl;
    vec4 sphere; // xyz=center, w=radius
};

mat4 quaternionToMatrix(vec4 q) {
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    return mat4(
        1.0 - 2.0*(y*y + z*z), 2.0*(x*y - w*z), 2.0*(x*z + w*y), 0.0,
        2.0*(x*y + w*z), 1.0 - 2.0*(x*x + z*z), 2.0*(y*z - w*x), 0.0,
        2.0*(x*z - w*y), 2.0*(y*z + w*x), 1.0 - 2.0*(x*x + y*y), 0.0,
        0.0, 0.0, 0.0, 1.0
    );
}

layout(std430, binding = 0) readonly buffer MDB {
    MDBO objects[];
} mdb;

layout(std430, binding = 1) buffer MB {
    MBO objects[];
} mb;

layout(binding = 2) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
} ubo;

layout(std430, binding = 3) buffer Counter {
    uint count;
};

// --- Frustum
struct Frustum {
    vec4 planes[6]; // x,y,z=normal, w=d
};

Frustum getFrustumPlanes(mat4 vp) {
    Frustum f;
    f.planes[0] = vp[3] + vp[0]; // Left
    f.planes[1] = vp[3] - vp[0]; // Right
    f.planes[2] = vp[3] + vp[1]; // Bottom
    f.planes[3] = vp[3] - vp[1]; // Top
    f.planes[4] = vp[3] + vp[2]; // Near
    f.planes[5] = vp[3] - vp[2]; // Far
    for (int i = 0; i < 6; i++) f.planes[i] /= length(f.planes[i].xyz);
    return f;
}

bool isSphereInFrustum(vec4 sphere, Frustum f) {
    vec3 center = sphere.xyz;
    float radius = sphere.w;
    for (int i = 0; i < 6; i++) {
        if (dot(f.planes[i].xyz, center) + f.planes[i].w < -radius) return false;
    }
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= mb.objects.length()) return;

    mat4 pos = mat4(1.0f);
    pos[3][0] = mdb.objects[idx].pos.x;
    pos[3][1] = mdb.objects[idx].pos.y;
    pos[3][2] = mdb.objects[idx].pos.z;

    mat4 rot = quaternionToMatrix(normalize(mdb.objects[idx].rot));

    mat4 scl = mat4(1.0f);
    scl[0][0] = mdb.objects[idx].scl.x;
    scl[1][1] = mdb.objects[idx].scl.y;
    scl[2][2] = mdb.objects[idx].scl.z;

    //mb.objects[idx].model = pos * rot * scl;

    Frustum frustum = getFrustumPlanes(ubo.proj * ubo.view);
    if (isSphereInFrustum(mdb.objects[idx].sphere, frustum)) {
        uint outIdx = atomicAdd(count, 1);
        mb.objects[outIdx].model = pos * rot * scl;
    }

    // memory barrier
    memoryBarrierBuffer();
    barrier();
}
