#version 460
layout (local_size_x = 128) in;

#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : enable

struct MBO {
    mat4 model;
};

struct MDBO {
    vec4 pos;
    vec4 rot;
    vec4 scl;
};

layout(scalar, buffer_reference) buffer MDB {
    MDBO objects[];
};

layout(scalar, buffer_reference) buffer MB {
    MBO objects[];
};

layout(scalar, buffer_reference) readonly buffer UMBO {
    mat4 view;
    mat4 proj;
    uint instancesCount;
};

layout(push_constant) uniform Push {
    MDB mdb;
    MB mb;
    UMBO umbo;
} pc;

mat4 quaternionToMatrix(vec4 q) {
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    return mat4(
        1.0 - 2.0*(y*y + z*z), 2.0*(x*y - w*z), 2.0*(x*z + w*y), 0.0,
        2.0*(x*y + w*z), 1.0 - 2.0*(x*x + z*z), 2.0*(y*z - w*x), 0.0,
        2.0*(x*z - w*y), 2.0*(y*z + w*x), 1.0 - 2.0*(x*x + y*y), 0.0,
        0.0, 0.0, 0.0, 1.0
    );
}


void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= pc.umbo.instancesCount) return;

    mat4 pos = mat4(1.0f);
    pos[3][0] = pc.mdb.objects[idx].pos.x;
    pos[3][1] = pc.mdb.objects[idx].pos.y;
    pos[3][2] = pc.mdb.objects[idx].pos.z;

    mat4 rot = quaternionToMatrix(normalize(pc.mdb.objects[idx].rot));

    mat4 scl = mat4(1.0f);
    scl[0][0] = pc.mdb.objects[idx].scl.x;
    scl[1][1] = pc.mdb.objects[idx].scl.y;
    scl[2][2] = pc.mdb.objects[idx].scl.z;

    pc.mb.objects[idx].model = pos * rot * scl;
}
